@page "/Register"
@using SymmetricalWaifu.Shared
@using System.Text
@using System.Security.Cryptography
@using System.Diagnostics
@inject HttpClient HttpClient

<p>Username</p>
<input @bind="_uname"/>
<p>Password</p>
<input @bind="_pwd" type="password"/>
<p>Display name</p>
<input @bind="_dname"/>
<p>Email (optional)</p>
<input @bind="_email"/>
<button @onclick="SendToServer">Register / Send to server</button>
@if (_showSalting)
{
    <p>Processing...</p>
}
@if (_showSending)
{
    <p>Registering...</p>
}
@if (_showSent)
{
    <p>Registered!</p>
}
@if (_showError)
{
    <p>Error: One or more fields are empty.</p>
}
@if (_showConnectionFailure)
{
    <p>Error: Connection with server failed.</p>
}

@code {

    private String? _uname, _pwd, _dname, _email;
    private Boolean _showSalting, _showSending, _showSent, _showError, _showConnectionFailure;
    private static Byte[] _hash = null!;
    private static SHA512 _sha512 = SHA512.Create();

    private async void SendToServer()
    {
        if (String.IsNullOrEmpty(_email)) _email = "";
        if (String.IsNullOrEmpty(_uname) || String.IsNullOrEmpty(_pwd) || String.IsNullOrEmpty(_dname))
        {
            _showError = true;
            return;
        }
        
        _showSalting = true;
        IEnumerable<Byte> pwd = Encoding.UTF32.GetBytes(_pwd);
        Byte[] salt = GenerateSalt();
        _hash = pwd.Concat(salt).ToArray();
        await ComputeSaltedHash();

        _showSending = true;
        StateHasChanged();
        var registrationRequest = new RegistrationRequest
        {
            Username = _uname,
            PasswordHash = _hash,
            PasswordSalt = salt,
            DisplayName = _dname,
            Email = _email
        };

        HttpResponseMessage result = await HttpClient.PostAsJsonAsync("AccountApi/Register", registrationRequest);
        if (result.IsSuccessStatusCode) _showSent = true;
        else _showConnectionFailure = true;
        StateHasChanged();
    }

    private static Byte[] GenerateSalt()
    {
        var salt = new Byte[128];
        var rng = RandomNumberGenerator.Create();
        rng.GetBytes(salt);
        return salt;
    }
    
    private readonly Resource _resource = new();
    private readonly CancellationTokenSource _cts = new();

    private async Task ComputeSaltedHash()
    {
        await Task.Delay(100, _cts.Token);
        _cts.Token.ThrowIfCancellationRequested();
        _resource.Compute();
    }

    public void Dispose()
    {
        _cts.Cancel();
        _resource?.Dispose();
    }

    private class Resource : IDisposable
    {
        private Boolean _disposed;

        public void Dispose()
        {
            if (_disposed) throw new ObjectDisposedException(nameof(Resource));
            _disposed = true;
        }

        public void Compute()
        {
            if (_disposed) throw new ObjectDisposedException(nameof(Resource));
            for (var i = 0; i < 5000; ++i) _hash = _sha512.ComputeHash(_hash);
        }
    }

}